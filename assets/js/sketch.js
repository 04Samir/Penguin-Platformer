/*

	&copy; 2022-Present

*/

// DECLARING VARIABLES
var game;

var ground;
var canyons;
var trees;
var clouds;
var mountains;

var character;

var collectables;
var pole;


function windowResized() {
	resizeCanvas(windowWidth, windowHeight);
}

// SET-UP
function setup() {

	// Creating Canvas
	createCanvas(windowWidth, windowHeight);

	// Initialising Variables
	game = {
		scroller: { // (Camera)
			x: 0
		},
		over: false,
		lives: 3,
		complete: false,
		score: 0
	};

	ground = { // (Floor)
		y: 400
	};


	// Initialising Objects to Create Instances
	character = new Character(width/2, ground.y);
	pole = new Pole(3000, 200);


	canyons = []; // Initialising with Empty Array first
	// Randomly Generate Co-Ordinates
	generate(200-800, 8, [800, 1000], [100, 200])
		.forEach( pos => {
			// Attempt to Fix any Conflictions with Other Objects
			const canyon = new Canyon(pos[0], pos[1]); // Create the 'Canyon' Instance
			
			// Check if the Generated Canyon is On/Near to the Character
			if (character.x-15 >= canyon.x && character.x <= canyon.x-15+canyon.width) {
				// If So... Change Co-Ordinates of Canyon to Remove Confliction
				const half = (canyon.x-5) + (canyon.width/2);
				if (character.x < half) {
					canyon.x = half + 5;
				}
				else if (character.x >= half) {
					canyon.width = canyon.width/2;
				};
			};
			// Check if the Generated Canyon is On/Near to the Flag-Pole
			if (pole.x >= canyon.x+5 && pole.x <= canyon.x-5+canyon.width) {
				// If So... Change Co-Ordinates of Canyon to Remove Confliction
				canyon.x = pole.x + 75;
			};
			// Finally, Add Canyons to Global Array
			canyons.push(canyon);
	});


	trees = []; // Initialising with Empty Array first
	// Randomly Generate Co-Ordinates
	generate(width/2-725, 30, [250, 300], [floor.y])
		.forEach( pos => {
			// Create the 'Tree' Instance
			const tree = new Tree(pos[0], pos[1]);
			trees.push(tree); // Finally, Add Tree to Global Array
	});
	// Attempt to Fix any Conflictions with Other Objects
	for (let i=0; i<trees.length; i++) {
		const tree = trees[i];

		// Check if the Generated Tree is On/Near to a Canyon
		canyons.forEach( canyon => {
			if (tree.x+5 >= canyon.x+5 && tree.x <= canyon.x-5+canyon.width) {
				// If it is... Remove it!
				trees.splice(i, 1);
			};
		});
	};

	clouds = []; // Initialising with Empty Array first
	// Randomly Generate Co-Ordinates
	generate(300, 21, [-300, -500], [75, 125, 70])
		.forEach( pos => {
			// Create the 'Cloud' Instance
			const cloud = new Cloud(pos[0], pos[1], 80);
			clouds.push(cloud); // Finally, Add Cloud to Global Array
	});


	mountains = []; // Initialising with Empty Array first
	// Randomly Generate Co-Ordinates
	generate(width/2-600, 5, [800, 1200], [ground.y-257])
		.forEach( pos => {
			// Attempt to Fix any Conflictions with Other Objects
			const mountain = new Mountain(pos[0], pos[1]);

			// Check if the Generated Mountain is On/Near to a Canyon
			canyons.forEach( canyon => {
				if (mountain.x+250 >= canyon.x+5 && mountain.x-250 <= canyon.x-5+canyon.width) {
					// If So... Change Co-Ordinates of Mountain to Remove Confliction
					if (mountain.x+250 >= canyon.x+5) {
						mountain.x = canyon.x - 250;
					}
					else if (mountain.x-250 <= canyon.x-5+canyon.width) {
						mountain.x = canyon.x + 250;
					};
				};
			});
			// Finally, Add Mountain to Global Array
			mountains.push(mountain);
	});


	collectables = []; // Initialising with Empty Array first
	// Randomly Generate Co-Ordinates
	generate(-180, 10, [300, 350], [ground.y])
		.forEach( pos => {
			// Attempt to Fix any Conflictions with Other Objects
			const collectable = new Collectable(pos[0], pos[1], 30, 45);
			
			// Check if the Generated Mountain is On/Near to a Canyon
			canyons.forEach( canyon => {
				if (collectable.x+30 >= canyon.x+5 && collectable.x-30 <= canyon.x-5+canyon.width) {
					// If So... Change Co-Ordinates of Mountain to Remove Confliction
					if (collectable.x+30 >= canyon.x+5) {
						collectable.x = canyon.x - 30;
					}
					else if (collectable.x-30 <= canyon.x-5+canyon.width) {
						collectable.x = canyon.x + 30;
					};
				};
			});
			// Finally, Add Collectable to Global Array
			collectables.push(collectable);
	});
};

/**
    * Randomly Generates a Set of X & Y Co-Ordinates

	* @param {number} start
	* @param {number} amount
	* @param {Readonly<Array<number>>} start
	* @param {Readonly<Array<number>>} start

	* @returns {Readonly<Array<number>>}
**/
function generate(start, amount, x_multiplier, y_range) {
	let temp = start; // Use this as Starting Point
	let ouput = []; // Initialing New Variable for Return
	for (let i=0; i<amount; i++) { // Iterating through Input Array
		// X-Co-Ordinate is Generated via the 'x_multiplier'
		// Y-Co-Ordinate is Generated by Choosing a Random Number from 'y_range'
		ouput.push([temp, y_range[floor(random()*y_range.length)]]);
		temp += random(x_multiplier[0], x_multiplier[1]) // Increase 'temp' via Multiplier
	};
	return ouput; // Finally, Return the Newly Generated Points
};


// INTERACTION FUNCTIONS

function keyPressed() {
	if (!game.over && !game.complete) { // Only Listen for Input if NOT Game Over AND NOT Level Complete 
		if (!character.isPlummeting) { // Only Listen for Input if NOT Plummeting
			if (keyCode == 37 || keyCode == 65) { // If 'A' or 'Left-Arrow' is Pressed
				character.isLeft = true; // Go Left
			} else if (keyCode == 39 || keyCode == 68) { // If 'D' or 'Right-Arrow' is Pressed
				character.isRight = true; // Go Right
			} else if (keyCode == 32 || keyCode == 38 || keyCode == 87) { // If 'W' or 'Up-Arrow' or 'SPACEBAR' is Pressed
				if (!character.isFalling) {
					character.isFalling = true; // Fall
					character.y -= 100; // Decrement Y to Show 'Falling'
				};
			};
		};
	};
};

function keyReleased() {
	if (keyCode == 37 || keyCode == 65) { // If 'A' or 'Left-Arrow' is Released
		character.isLeft = false; // Stop Going Left
	} else if (keyCode == 39 || keyCode == 68) { // If 'D' or 'Right-Arrow' is Released
		character.isRight = false; // Stop Going Right
	};
};



// DRAW FUNCTIONS

function draw() {
	// Creating Background
	background(100, 155, 255); // Blue Sky
	
	noStroke();

	// Creating Ground
	fill(64, 224, 208); // Water Background
	rect(0, ground.y, width, height-ground.y);
	fill(255); // White Ice/Snowy Floor
	rect(0, ground.y, width, height-ground.y-150);


	push(); // Using 'push()' so that Selected Entities will Only get Translated
		game.scroller.x = character.x - (width/2); // Get Position of Centre
		translate(-game.scroller.x, 0); // Translate so that Character stays in Centre

		// Creating Canyons
		canyons.forEach( canyon => { // Iterating through Array
			canyon.draw(); // Call Function to Draw Object
		});

		// Drawing Clouds
		clouds.forEach( cloud => { // Iterating through Array
			cloud.draw(); // Call Function to Draw Object
		});
		// Drawing Mountains
		mountains.forEach( mountain => { // Iterating through Array
			mountain.draw(); // Call Function to Draw Object
		});
		// Drawing Trees
		trees.forEach( tree => { // Iterating through Array
			tree.draw(); // Call Function to Draw Object
		});

		// Draw Collectables (Egg)
		collectables.forEach( collectable => { // Iterating through Array
			collectable.draw(); // Call Function to Draw Object
		});

		// Draw Pole
		pole.draw(); // Call Function to Draw Object


		// Draw Character (Penguin)
		if (character.isPlummeting) { // If Plummeting
			character.plumment(); // Call Function to Draw Object's Current State
		} else if(character.isLeft && character.isFalling) { // If Jumping-Left
			character.fallLeft(); // Call Function to Draw Object's Current State
		} else if(character.isRight && character.isFalling) { // If Jumping-Right
			character.fallRight(); // Call Function to Draw Object's Current State
		} else if(character.isLeft) { // If Going-Left
			character.goLeft(); // Call Function to Draw Object's Current State
		} else if(character.isRight) { // If Going-Right
			character.goRight(); // Call Function to Draw Object's Current State
		} else if(character.isFalling || character.isPlummeting) { // If Falling or Plummeting
			character.fall(); // Call Function to Draw Object's Current State
		} else { // If Standing
			character.draw(); // Call Function to Draw Object's Current State
		};
	pop(); // Use 'pop()' to Now Stop Translating Objects


	// INTERACTIONS

	// Check if Character is within a Canyon
	character.isOverCanyon = false; // Useful Variable for a Global Scope
	canyons.forEach( canyon => { // Iterating through Array
		// If Character is withing X-Co-Ordinates of Canyon
		if (character.x-15 >= canyon.x && character.x <= canyon.x-15+canyon.width) {
			character.isOverCanyon = true; // Set to True
			// If Character has Fallen into Canyon
			if (character.y >= ground.y) {
				character.isOverCanyon = false; // Reset

				if (game.lives >= 1) { // Show Message to User
					fill(255);
					strokeWeight(3);
					stroke(0);
					textSize(40);
					textAlign(CENTER);
					fill(255, 105, 105);
					text("LIFE LOST", width/2, height/2);
				};

				// Set Plummeting to True
				if (!character.isPlummeting) {
					character.isPlummeting = true;
					game.lives --; // Decrement Game Lives
				}
				else if (character.y-65 >= height) { // If Character has Fallen to Bottom
					// Reset State
					character.reset();
				};
			};
		};
	});

	// Check if Character is in Range of a Collectable
	collectables.forEach( collectable => { // Iterating through Array
		if (character.y !== ground.y) { // If Jumping, Account for Y-Co-Ordinates
			if ((dist(character.x, character.y, collectable.x, collectable.y) <= collectable.height) && (!collectable.isFound)) {
				// Successfully Found
				collectable.isFound = true;
				game.score ++; // Increment Game Score
			};
		} else if ((dist(character.x, character.y, collectable.x, collectable.y) <= collectable.width) && (!collectable.isFound)) {
			// Successfully Found
			collectable.isFound = true;
			game.score ++; // Increment Game Score
		};
	});

	// Check if Character is in Range of Pole
	if ((dist(character.x, character.y, pole.x+22, character.y) <= 20) && (!pole.isReached)) {
		// Set Reached & Level Complete to True
		pole.isReached = game.complete = true;
		// Stop Any Current Movement
		character.isLeft = character.isRight = false;
	};


	// Gravity
	if (character.y < ground.y) { // If Character is NOT on Ground
		character.y += 1 // Increment Y-Co-ordinate to Slowly Bring Character to Ground
		if (character.y == ground.y) {
			// Reset Variable when Back on Ground
			character.isFalling = false;
		};
	};


	fill(255);
	strokeWeight(3);
	stroke(0);
	// If Character is On Left World Boundary
	if (character.x - width/2 <= -1234) {
		character.reachedBoundary = true; // Useful Global Variable
		// Display Message to User
		textSize(40);
		textAlign(CENTER);
		fill(255, 105, 105);
		text("BOUNDARY REACHED", width/2, height/2);
	}
	else {
		// Reset Variable
		character.reachedBoundary = false;
	};


	// DRAW TEXT
	textSize(22);
	textAlign(CENTER);
	text(`SCORE : ${game.score} / ${collectables.length}`, 100, 50);
	text(`LIVES : ${game.lives} / 3`, 100, 75);
	if (game.lives <= 0) { // Decide whether it is Game Over or Not
		game.over = true; // If 0 Lives Left, then Game Over
	};
	if (game.over) { // If Game Over...
		// Display Text to User
		textSize(100);
		textAlign(CENTER);
		fill(255, 105, 105);
		strokeWeight(10);
		text("GAME OVER", width/2, height/2);
		textSize(50);
		text("Refresh the Page to Retry", width/2, height/2+75);
	};
	if (game.complete) { // If Level Complete...
		// Display Text to User
		textSize(100);
		textAlign(CENTER);
		fill(138, 255, 157);
		strokeWeight(10);
		text("LEVEL COMPLETE", width/2, height/2);
	};
};


// DECLARING CLASSES

/**
 	* Function Constructor Representing Game-Character

	* @param {number} x
	* @param {number} y
**/
function Character(x, y) {
	// Initialising Variables
	this.x = x;
	this.y = y;
	this.isLeft = false;
	this.isRight = false;
	this.isFalling = false;
	this.isPlummeting = false;
	this.speed = 6;
	this.isOverCanyon = false;
	this.reachedBoundary = false;

	// Reset All Variables to Default State
	this.reset = function() {
		this.x = width/2;
		this.y = ground.y;
		this.isLeft = this.isRight = this.isPlummeting = this.isFalling = this.isOverCanyon = this.reachedBoundary = false;
	};

	// Draw Plummeting State
	this.plumment = function() {
		this.y += 3; // Increment to Show Falling

		noStroke();
		fill(0); // Black
		ellipse(this.x, this.y-60, 30); // Head
		ellipse(this.x, this.y-30, 40, 60); // Outer Body
		// Right Arm
		ellipse(this.x+20, this.y-50, 10, 25);
		// Left Arm
		ellipse(this.x-20, this.y-50, 10, 25);
		fill(255); // White
		ellipse(this.x, this.y-30, 30, 45); // Inner body
		ellipse(this.x-6, this.y-62, 10); // Left Outer-Eye
		ellipse(this.x+6, this.y-62, 10); // Right Outer-Eye
		fill(0); // Black
		ellipse(this.x-6, this.y-64, 4); // Left Inner-Eye
		ellipse(this.x+6, this.y-64, 4); // Right Inner-Eye
		fill(255, 183, 110); // Orangey-Yellow
		ellipse(this.x, this.y-54, 15, 10); // Nose
		ellipse(this.x-7, this.y-2, 15, 10); // Left Foot
		ellipse(this.x+7, this.y-2, 15, 10); // Right Foot
	};

	// Draw Falling-Left State
	this.fallLeft = function() {
		// If at Boundary, DO NOT Decrement
		if (!this.reachedBoundary) {
			this.x -= this.speed;
		};

		noStroke();

		// If NOT Over a Canyon, Draw Shadow
		if (!this.isOverCanyon) {
			fill(100, 100, 100, 150);
		  	ellipse(this.x, ground.y+7, 40, 15);	
		};


		fill(0); // Black
		ellipse(this.x, this.y-60, 30); // Head
		ellipse(this.x, this.y-30, 30, 60); // Outer Body
		fill(255); // White
		ellipse(this.x-9, this.y-30, 10, 30); // Inner body
		ellipse(this.x-9, this.y-62, 10); // Left Outer-Eye
		fill(0); // Black
		ellipse(this.x-11, this.y-65, 4); // Left Inner-Eye
		fill(255, 183, 110); // Orangey-Yellow
		ellipse(this.x-11, this.y-54, 15, 10); // Nose
		ellipse(this.x-5, this.y-2, 15, 10); // Feet
	};

	// Draw Falling-Right State
	this.fallRight = function() {
		this.x += this.speed; // Increment to Show Movement
		
		noStroke();

		// If NOT Over a Canyon, Draw Shadow
		if (!this.isOverCanyon) {
			fill(100, 100, 100, 150);
			ellipse(this.x, ground.y+7, 40, 15);
		};

		fill(0); // Black
		ellipse(this.x, this.y-60, 30); // Head
		ellipse(this.x, this.y-30, 30, 60); // Outer Body
		fill(255); // White
		ellipse(this.x+9, this.y-30, 10, 30); // Inner body
		ellipse(this.x+9, this.y-62, 10); // Right Outer-Eye
		fill(0); // Black
		ellipse(this.x+11, this.y-65, 4); // Right Inner-Eye
		fill(255, 183, 110); // Orangey-Yellow
		ellipse(this.x+11, this.y-54, 15, 10); // Nose
		ellipse(this.x+5, this.y-2, 15, 10); // Feet
	};

	// Draw Left State
	this.goLeft = function() {
		// If at Boundary, DO NOT Decrement
		if (!this.reachedBoundary) {
			this.x -= this.speed;
		};

		noStroke();

		// If NOT Over a Canyon, Draw Shadow
		if (!this.isOverCanyon) {
			fill(100, 100, 100, 150);
			ellipse(this.x+25, ground.y+7, 80, 15);
		};

		fill(0); // Black
		ellipse(this.x, this.y-15, 30); // Head
		ellipse(this.x+30, this.y-15, 60, 30); // Outer Body
		fill(255); // White
		ellipse(this.x+30, this.y-5, 40, 10); // Inner body
		ellipse(this.x-9, this.y-17, 10); // Left Outer-Eye
		fill(0); // Black
		ellipse(this.x-11, this.y-17, 4); // Left Inner-Eye
		fill(255, 183, 110); // Orangey-Yellow
		ellipse(this.x-11, this.y-9, 15, 10); // Nose
		ellipse(this.x+60, this.y-10, 10, 15); // Feet
	};

	// Draw Right State
	this.goRight = function() {
		this.x += this.speed; // Increment to Show Movement

		noStroke();

		// If NOT Over a Canyon, Draw Shadow
		if (!this.isOverCanyon) {
			fill(100, 100, 100, 150);
			ellipse(this.x-25, ground.y+7, 80, 15);
		};

		fill(0); // Black
		ellipse(this.x, this.y-15, 30); // Head
		ellipse(this.x-30, this.y-15, 60, 30); // Outer Body
		fill(255); // White
		ellipse(this.x-30, this.y-5, 40, 10); // Inner body
		ellipse(this.x+9, this.y-17, 10); // Left Outer-Eye
		fill(0); // Black
		ellipse(this.x+11, this.y-17, 4); // Left Inner-Eye
		fill(255, 183, 110); // Orangey-Yellow
		ellipse(this.x+11, this.y-9, 15, 10); // Nose
		ellipse(this.x-60, this.y-10, 10, 15); // Feet
	};

	// Draw Falling States
	this.fall = function() {
		noStroke();

		// If NOT Over a Canyon, Draw Shadow
		if (!this.isOverCanyon) {
			fill(100, 100, 100, 150);
			ellipse(this.x, ground.y+7, 40, 15);
		};

		fill(0); // Black
		ellipse(this.x, this.y-60, 30); // Head
		ellipse(this.x, this.y-30, 40, 60); // Outer Body
		// Right Arm
		ellipse(this.x+20, this.y-50, 10, 25);
		// Left Arm
		ellipse(this.x-20, this.y-50, 10, 25);
		fill(255); // White
		ellipse(this.x, this.y-30, 30, 45); // Inner body
		ellipse(this.x-6, this.y-62, 10); // Left Outer-Eye
		ellipse(this.x+6, this.y-62, 10); // Right Outer-Eye
		fill(0); // Black
		ellipse(this.x-6, this.y-64, 4); // Left Inner-Eye
		ellipse(this.x+6, this.y-64, 4); // Right Inner-Eye
		fill(255, 183, 110); // Orangey-Yellow
		ellipse(this.x, this.y-54, 15, 10); // Nose
		ellipse(this.x-7, this.y-2, 15, 10); // Left Foot
		ellipse(this.x+7, this.y-2, 15, 10); // Right Foot
	};

	// Draw Normal State
	this.draw = function() {
		noStroke();

		// If NOT Over a Canyon, Draw Shadow
		if (!this.isOverCanyon) {
			fill(100, 100, 100, 150);
			ellipse(this.x, ground.y+7, 40, 15);
		};

		fill(0); // Black
		ellipse(this.x, this.y-60, 30); // Head
		ellipse(this.x, this.y-30, 40, 60); // Outer Body
		fill(255); // White
		ellipse(this.x, this.y-30, 30, 45); // Inner body
		ellipse(this.x-6, this.y-62, 10); // Left Outer-Eye
		ellipse(this.x+6, this.y-62, 10); // Right Outer-Eye
		fill(0); // Black
		ellipse(this.x-6, this.y-62, 4); // Left Inner-Eye
		ellipse(this.x+6, this.y-62, 4); // Right Inner-Eye
		fill(255, 183, 110); // Orangey-Yellow
		ellipse(this.x, this.y-54, 15, 10); // Nose
		ellipse(this.x-7, this.y-2, 15, 10); // Left Foot
		ellipse(this.x+7, this.y-2, 15, 10); // Right Foot
	};
};


/**
 	* Function Constructor Representing Canyon

	* @param {number} x
	* @param {number} width
**/
function Canyon(x, width) {
	// Initialising Variables
	this.x = x;
	this.width = width;

	// Draw the Canyon
	this.draw = function() {
		const half = (height-ground.y-150) / 2;

		noStroke();

		fill(100, 155, 255);
		rect(this.x, ground.y, this.width, half);

		fill(64, 224, 208);
		rect(this.x, ground.y+half, this.width, half);

		fill(255);
		rect(this.x-5, ground.y, 10+5, height-ground.y-150, 0, 10, 10, 0);
		rect(this.x+this.width-5, ground.y, 10+5, height-ground.y-150, 10, 0, 0, 10);
	};
};


/**
 	* Function Constructor Representing Cloud

	* @param {number} x
	* @param {number} y
	* @param {number} size
**/
function Cloud(x, y, size) {
	// Initialising Variables
	this.x = x;
	this.y = y;
	this.size = size;

	// Draw the Cloud
	this.draw = function() {
		noStroke();

		if (this.x > width*3) { // If Reached End...
			this.x = 0; // Reset to Beginning
		};
		this.x ++; // Increment to Show Movement

		// Drawing Shadows
		fill(180); // Shadow Colour
		ellipse(this.x-5, this.y+8, this.size, this.size-15)
		ellipse(this.x-45, this.y+18, this.size-20, this.size-40);
		ellipse(this.x+35, this.y+18, this.size-20, this.size-35);

		// Actual Cloud
		fill(255); // White
		ellipse(this.x, this.y, this.size, this.size-15);
		ellipse(this.x-40, this.y+10, this.size-20, this.size-40);
		ellipse(this.x+40, this.y+10, this.size-20, this.size-35);
	};
};


/**
 	* Function Constructor Representing Collectable

	* @param {number} x
	* @param {number} y
	* @param {number} width
	* @param {number} height
**/
function Collectable(x, y, width, height) {
	// Initialising Variables
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.isFound = false;


	// Draw the Collectab;e
	this.draw = function() {
		if (!this.isFound) { // Only Draw if NOT Found
			noStroke();
			fill(254, 255, 171); // Light Yellow
			ellipse(this.x, this.y-22, this.width, this.height);
			fill(193, 194, 97); // Darker Yellow
			ellipse(this.x-5, this.y-33, this.width-20, this.height-30);
		}
	};
};


/**
 	* Function Constructor Representing Tree

	* @param {number} x
**/
function Tree(x) {
	// Initialising Variables
	this.x = x;
	this.y = ground.y;

	// Draw Tree
	this.draw = function() {
		noStroke();

		// Trunk
		fill(120, 100, 40); // Brown
		rect(this.x, this.y-100, 20, 100);
		// Shadow
		fill(70, 80, 70, 200);
		triangle(this.x+10, this.y-30, this.x, this.y-30, this.x, this.y);
		
		// Branches
		fill(50, 120, 50); // Green Colour
		triangle(this.x-30, this.y-30, this.x+10, this.y-90, this.x+50, this.y-30); // First Leaf Lathis.yer
		triangle(this.x-25, this.y-60, this.x+10, this.y-120, this.x+45, this.y-60); // Second Leaf Lathis.yer
		
		// Ice Cap
		fill(255); // White
		beginShape(); // Used to Make a Shape from vertex
			vertex(this.x+10, this.y-120);
			vertex(this.x+22, this.y-100);
			vertex(this.x+13, this.y-80);
			vertex(this.x+5, this.y-90);
			vertex(this.x-13.25, this.y-80);
		endShape(); // Ending Shape
		
		// Shadow
		fill(0, 0, 0, 100);
		triangle(this.x-25, this.y-60, this.x+10, this.y-120, this.x-10, this.y-60);
		triangle(this.x-30, this.y-30, this.x+4, this.y-80, this.x-5, this.y-30);
	};
};


/**
 	* Function Constructor Representing Mountain

	* @param {number} x
	* @param {number} y
**/
function Mountain(x, y) {
	// Initialising Variables
	this.x = x;
	this.y = y;


	// Draw Mountain
	this.draw = function() {
		noStroke();

		// Draw Mountains
		fill(100); // Grey

		// Draw Background Mountain First
		triangle(this.x, this.y, this.x-220, this.y+257, this.x+160, this.y+257);

		// Background Mountain's Ice Cap
		fill(255); // White
		beginShape(); // Used to Make a Shape from Vertex
			vertex(this.x, this.y);
			vertex(this.x-30, this.y+35);
			vertex(this.x-68, this.y+80);
			vertex(this.x-15, this.y+35);
			vertex(this.x, this.y+50);
			vertex(this.x+15, this.y+70);
			vertex(this.x+20, this.y+40);
			vertex(this.x+31, this.y+50);
		endShape(); // Ending Shape

		// Background Mountain's Shadow
		fill(0, 0, 0, 100); // Colour Black with Transparency
		triangle(this.x, this.y, this.x-220, this.y+257, this.x-20, this.y+257);

		// Draw Foreground Mountain Nethis.xt
		fill(150);
		triangle(this.x-100, this.y-50, this.x-250, this.y+257, this.x+50, this.y+257);

		// Foreground Mountain's Ice Cap
		fill(255); // White
		beginShape(); // Used to Make a Shape from Vertex
			vertex(this.x-100, this.y-50);
			vertex(this.x-129, this.y+10);
			vertex(this.x-110, this.y);
			vertex(this.x-80, this.y+30);
			vertex(this.x-70, this.y+10);
		endShape(); // Ending Shape

		// Foreground Mountain's Shadow
		fill(0, 0, 0, 100); // Colour Black with Transparency
		triangle(this.x-100, this.y-50, this.x-250, this.y+257, this.x-140, this.y+257);
	};
};


/**
 	* Function Constructor Representing Pole

	* @param {number} x
	* @param {number} y
**/
function Pole(x, y) {
	// Initialising Variables
	this.x = x;
	this.y = y;
	this.flag = {
		x: this.x+7,
		y: ground.y-75
	};
	this.isReached = false;

	// Draw Flag-Pole
	this.draw = function() {
		noStroke();

		fill(255); // White this
		rect(this.x, this.y, 7, ground.y-this.y, 20, 20, 0, 0);
		
		// Raise Flag
		if (this.isReached) {
			this.flag.y = min(ground.y+40, this.flag.y+1);
		};

		// Draw Flag
		fill(139, 0, 0); // Red Flag
		triangle(this.flag.x, this.flag.y-50, this.flag.x, this.flag.y-100, this.flag.x+60, this.flag.y-75);
	};
};
